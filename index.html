<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Particle Sphere Audio Visualizer</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #0ff;
    }
    #hint {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 6px;
      border: 1px solid #0ff;
      font-size: 14px;
      color: #0ff;
      backdrop-filter: blur(4px);
    }
    #hint button {
      margin-left: 8px;
      padding: 4px 10px;
      border-radius: 4px;
      border: 1px solid #0ff;
      background: transparent;
      color: #0ff;
      cursor: pointer;
    }
    #hint button:hover {
      background: #0ff;
      color: #000;
    }
  </style>
</head>
<body>
  <div id="hint">
    ðŸŽ§ Click "Start" then play music near your mic
    <button id="startBtn">Start</button>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // ==============
    // BASIC SETUP
    // ==============
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 28;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    // ==============
    // PARTICLE SPHERE (MAIN VISUALIZER)
    // ==============
    const SPHERE_POINTS = 900; // number of dots on sphere surface
    const sphereGeometry = new THREE.BufferGeometry();
    const spherePositions = new Float32Array(SPHERE_POINTS * 3);
    const basePositions = new Float32Array(SPHERE_POINTS * 3);

    const sphereRadius = 7;

    for (let i = 0; i < SPHERE_POINTS; i++) {
      const i3 = i * 3;

      // Fibonacci sphere distribution for uniform points[web:35]
      const y = 1 - (i / (SPHERE_POINTS - 1)) * 2;
      const radiusAtY = Math.sqrt(1 - y * y);
      const goldenAngle = Math.PI * (3 - Math.sqrt(5));
      const theta = goldenAngle * i;

      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;

      basePositions[i3] = x * sphereRadius;
      basePositions[i3 + 1] = y * sphereRadius;
      basePositions[i3 + 2] = z * sphereRadius;

      spherePositions[i3] = basePositions[i3];
      spherePositions[i3 + 1] = basePositions[i3 + 1];
      spherePositions[i3 + 2] = basePositions[i3 + 2];
    }

    sphereGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(spherePositions, 3)
    );

    const sphereMaterial = new THREE.PointsMaterial({
      color: 0x00ffff,
      size: 0.19,
      transparent: true,
      depthWrite: false,
      opacity: 0.95
    });

    const particleSphere = new THREE.Points(sphereGeometry, sphereMaterial);
    scene.add(particleSphere);

    // ==============
    // BACKGROUND PARTICLES (AMBIENT)
    // ==============
    const BG_COUNT = 650;
    const bgGeometry = new THREE.BufferGeometry();
    const bgPositions = new Float32Array(BG_COUNT * 3);
    const bgVelocities = new Float32Array(BG_COUNT * 3);
    const bgRadius = 45;

    for (let i = 0; i < BG_COUNT; i++) {
      const i3 = i * 3;

      const r = bgRadius * (0.4 + Math.random() * 0.6);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      bgPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
      bgPositions[i3 + 1] = r * Math.cos(phi);
      bgPositions[i3 + 2] = r * Math.sin(phi) * Math.sin(theta);

      bgVelocities[i3] = (Math.random() - 0.5) * 0.02;
      bgVelocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
      bgVelocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
    }

    bgGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(bgPositions, 3)
    );

    const bgMaterial = new THREE.PointsMaterial({
      color: 0x0088ff,
      size: 0.18,
      transparent: true,
      depthWrite: false,
      opacity: 0.6
    });

    const bgParticles = new THREE.Points(bgGeometry, bgMaterial);
    scene.add(bgParticles);

    // ==============
    // AUDIO SETUP
    // ==============
    let analyser = null;
    let dataArray = null;
    let audioCtx = null;

    const startBtn = document.getElementById("startBtn");

    async function initAudio() {
      if (analyser) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === "suspended") {
          await audioCtx.resume();
        }

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); // mic[web:11]
        const source = audioCtx.createMediaStreamSource(stream);

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        source.connect(analyser);

        startBtn.textContent = "Running...";
        startBtn.disabled = true;
      } catch (err) {
        console.error(err);
        alert("Mic access failed. Please allow microphone permission and reload.");
      }
    }

    startBtn.addEventListener("click", () => {
      initAudio();
    });

    // ==============
    // ANIMATION
    // ==============
    let time = 0;

    function animate() {
      requestAnimationFrame(animate);

      let avg = 0;
      if (analyser && dataArray) {
        analyser.getByteFrequencyData(dataArray);
        avg = dataArray.reduce((s, v) => s + v, 0) / dataArray.length || 0;
      }

      const loudness = avg / 255;

      time += 0.01 + loudness * 0.02;

      // ---- MAIN SPHERE EXPANSION (3D) ----
      const baseScale = 1 + 0.12 * Math.sin(time * 2);
      const expand = 0.8 * loudness;
      const scale = baseScale + expand;

      const sphereAttr = sphereGeometry.getAttribute("position");
      const arr = sphereAttr.array;

      for (let i = 0; i < SPHERE_POINTS; i++) {
        const i3 = i * 3;
        arr[i3] = basePositions[i3] * scale;
        arr[i3 + 1] = basePositions[i3 + 1] * scale;
        arr[i3 + 2] = basePositions[i3 + 2] * scale;
      }
      sphereAttr.needsUpdate = true;
      particleSphere.rotation.y += 0.01 + loudness * 0.03;
      particleSphere.rotation.x = 0.15 + loudness * 0.25;

      // sphere color
      const hue = 190 + loudness * 60;
      const lightness = 0.45 + loudness * 0.35;
      sphereMaterial.color.setHSL(hue / 360, 0.9, lightness);
      sphereMaterial.opacity = 0.6 + loudness * 0.4;

      // ---- BACKGROUND PARTICLES ----
      const bgAttr = bgGeometry.getAttribute("position");
      const bgArr = bgAttr.array;

      for (let i = 0; i < BG_COUNT; i++) {
        const i3 = i * 3;

        bgPositions[i3] += bgVelocities[i3];
        bgPositions[i3 + 1] += bgVelocities[i3 + 1];
        bgPositions[i3 + 2] += bgVelocities[i3 + 2];

        const dx = bgPositions[i3];
        const dy = bgPositions[i3 + 1];
        const dz = bgPositions[i3 + 2];
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

        const push = 0.05 * loudness;
        bgPositions[i3] += (dx / dist) * push;
        bgPositions[i3 + 1] += (dy / dist) * push;
        bgPositions[i3 + 2] += (dz / dist) * push;

        const maxDist = bgRadius * 1.4;
        if (dist > maxDist) {
          bgPositions[i3] *= 0.9;
          bgPositions[i3 + 1] *= 0.9;
          bgPositions[i3 + 2] *= 0.9;
        }

        bgArr[i3] = bgPositions[i3];
        bgArr[i3 + 1] = bgPositions[i3 + 1];
        bgArr[i3 + 2] = bgPositions[i3 + 2];
      }
      bgAttr.needsUpdate = true;
      bgMaterial.opacity = 0.35 + loudness * 0.6;

      renderer.render(scene, camera);
    }

    animate();

    // ==============
    // RESIZE
    // ==============
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
